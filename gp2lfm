#!/bin/bash

#google play to lastfm
#runs in the folder with gplay data downloads and modifies the data accordingly

#set size to make files toupload
uploadsize=3000

if [[ -z $1 ]]; then
    outputfile=outputfile
else
    outputfile=$1
fi
touch outputfile
rm outputfile #how was this not always here lmao
rm removedlines

songcount=0
linecount=0

for file in *.csv; do

    #echo $file
    songcount=$((songcount + 1))
    
    line=$(awk 'NR >= 2 { print }' < "$file") #assign second line to variable
    #echo $line
    
    #parse and remove quotations around everything
    #extract title
    title=$(gawk '
    BEGIN {
        FPAT = "([^,]+)|(\"[^\"]+\")" #complex delimiter stuff
        OFS = "," #output field seperator
    }
    {
    if ($1 != "Title") #skip header line as long as song isnt called "Title"
    {         
        title=$1
        { print title}
    }
    }
    ' "$file")
    title="${title%\"}"
    title="${title#\"}"
    
    #extract album
    album=$(gawk '
    BEGIN {
        FPAT = "([^,]+)|(\"[^\"]+\")" #complex delimiter stuff
        OFS = "," #output field seperator
    }
    {
    if ($1 != "Title") #skip header line as long as song isnt called "Title"
    {         
        album=$2
        { print album}
    }
    }
    ' "$file")
    
    album="${album%\"}"
    album="${album#\"}"
    
    #extract artist
    artist=$(gawk '
    BEGIN {
        FPAT = "([^,]+)|(\"[^\"]+\")" #complex delimiter stuff
        OFS = "," #output field seperator
    }
    {
    if ($1 != "Title") #skip header line as long as song isnt called "Title"
    {         
        artist=$3
        { print artist}
    }
    }
    ' "$file")
    
    #everything be like
    artist="${artist%\"}"
    artist="${artist#\"}"

    #extract duration
    durationms=$(gawk '
    BEGIN {
        FPAT = "([^,]+)|(\"[^\"]+\")" #complex delimiter stuff
        OFS = "," #output field seperator
    }
    {
    if ($1 != "Title") #skip header line as long as song isnt called "Title"
    {         
        dms=$4
        { print dms}
    }
    }
    ' "$file")
    
    #everything be like
    durationms="${durationms%\"}"
    durationms="${durationms#\"}"
    
    #complex parse - extract playcount
    pc=$(gawk '
    BEGIN {
        FPAT = "([^,]+)|(\"[^\"]+\")" #complex delimiter stuff
        OFS = "," #output field seperator
    }
    {
    if ($1 != "Title") # Do not forget to skip the header line! - does this work for songs that are titled Title?
    {         
        playcount=$6
        
        #print out to variable
        { print playcount}
    }
    }
    ' "$file")
    
    #playcount be like
    pc="${pc%\"}"
    pc="${pc#\"}"

    #concatenate strings (in this case its a good thing the encodings messed up and they don't have quotes
    line="$title,$album,$artist,$durationms,$pc"

    while [[ $pc > 0 ]]; do
        linecount=$((linecount + 1))
        #append line to file
        echo $line >> $outputfile
        pc=$(($pc - 1))
    done

done

echo songs: $songcount
echo lines: $linecount

#replace shitty formatting from gplay
sed -i -e 's/&#39;/'\''/g' $outputfile
sed -i -e 's/&quot;/"/g' $outputfile
sed -i -e 's/&amp;/\&/g' $outputfile
sed -i -e 's/&gt;/>/g' $outputfile
sed -i -e 's/&lt;/</g' $outputfile

echo "fixed formatting in outpputfile"

#remove podcasts or whatever
declare -a todelete=("default thing to delete yo, I hope you don't have a song with this name"
                     #"Replace"
                     #"And Uncomment"
                     #"These Strings"
                     )

for shittodelete in "${todelete[@]}"; do {
    echo "seperating $shittodelete ... lines moved: "
    grep -i "$shittodelete" $outputfile | wc -l
    
    grep -v -i "$shittodelete" $outputfile > temp         #takes the songs that do not have the string defined above
    grep -i "$shittodelete" $outputfile >> removedlines   #adds the lines that have the filtered words to new file
    mv temp $outputfile                                   #overwrite previous file with the new filtered one. can change 'mv' to 'cp' if you want to check intermediate temp file
    
} done

#cut this file into files of specified length (default 3000)
mkdir -p toupload
split outputfile "toupload_" -l $(($uploadsize)) -d

for file in toupload_*; do
    mv $file "toupload/$file.csv"
done

##more management
#sort -k4 -n -t, outputfile > lengthsort #sorts the code based on song length if you want to know - i just used this to help with my spotify code descision making
